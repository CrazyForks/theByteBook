# 5.3.1 可靠事件队列

2008 年，eBay 的系统架构师 Dan Pritchett 在 ACM 发表了论文《Base: An Acid Alternative》[^1]，文中作者基于实践总结出一种独立  ACID 之外，通过引入消息队列和幂等来达成一致性目的系统化技术手段，并提出了最终一致性的概念。

从论文的名字就可以看出最终一致性的概念与 ACID 强一致性对立。因为 ACID 在英文中有的“酸”的含义，这个模型明显刻意拼凑成 BASE（BASE 在英文中有碱的含义）。有酸 vs 碱这个计算机浑然天成的梗加成，Dan Pritchett 论文被广泛传播，BASE 理论和最终一致性也被大家熟悉。


BASE 是 Basically Available, Soft state, Eventually consistent 的缩写，其核心理念为：

- 基本可用（Basically Available）：系统保证在大多数情况下能够提供服务，即使在某些节点出现故障时，系统仍会尽可能地保持可用。这意味着系统会优先保障可用性而非一致性。
- 柔性状态（Soft state）：系统状态允许在一段时间内处于不一致状态。与 ACID 的强一致性要求不同，BASE 允许系统在更新过程中状态是“柔性”的，即数据可以在某些节点上暂时不一致，直到系统最终达到一致性。
- 最终一致性（Eventually consistent）：系统在经过一段时间后会达到一致性。即使在网络分区或系统故障的情况下，数据最终会被同步到所有节点，保证最终的一致性。最终一致性强调的是系统在经过足够的时间和重复的数据同步操作后，所有节点的数据将会一致。
Basically Available（基本可用）、Soft State（软状态）和Eventual Consistency（最终一致性）：

BASE 理论是对 CAP 定理中 AP（可用性和分区容错性）方案的延伸，强调在分布式系统中，即使无法做到强一致性，也可以通过适当的方式使系统达到最终一致性。Dan Pritchett 在论文中提到的适当的方式，可以总结为基于可靠事件队列的事件驱动模式。这个模式的关键在于确保事件的可靠投递和避免重复消费。幸运的是，当前流行的消息中间件已经普遍实现了事件持久化和至少一次投递机制。此外，幂等性的实现也有成熟的解决方案，因此这些问题已不再是难点。


下面，笔者以一个具体的例子帮助你理解“可靠事件队列”的具体做法。假设有这么一个电商系统，下单需要 3 个服务支持：支付服务（银行扣款）、库存服务（扣除购买商品的库存）、积分服务（为用户增加积分）。下单过程中最核心、出错影响最大的服务优先处理，即支付扣款 -> 仓库出库 -> 为用户增加积分。整个过程如图 6-2 所示。

:::center
  ![](../assets/BASE.svg)<br/>
  图 5-2 可靠事件队列模型
:::

1. 用户向商店发送一个交易请求，譬如购买价值 ￥100 的某个商品。
2. 支付服务创建一个本地的扣款事务，如果扣款成功，则在自己的数据库内建立一张消息表，表内如下结构：事务 ID，扣款￥100（状态：已完成），仓库出库（状态：待进行），赠送积分(状态：待进行)。
3. 在系统内建立一个消息服务，定时轮询消息表，将状态是“进行中”的消息同时发送到库存和积分服务节点中。这个时候会产生以下几种情况：
	- 仓库服务和积分服务都顺利完成了出库和加分的工作，向支付服务返回执行结果，支付服务把消息改为“已完成”。整个事务顺利完成，最终实现一致性。
	- 仓库服务和积分服务至少有一个因网络问题，未能收到来自支付服务的消息。此时，由于支付服务存储的消息状态一直处于“进行中”，所以消息服务器将在每次轮询的时候持续地向未响应的服务重复发送消息。**这个重复的操作决定着所有被消息服务器发送的消息操作都必须具备幂等性**（幂等性设计可以参考 5.3.4） 节内容。如此，出库以及增加积分的动作只会被处理一次。此过程持续自动重复至双方通信恢复正常。
	- 仓库服务和积分服务因某个原因无法完成处理，譬如仓库发现商品无货，此时，仍然继续持续发送消息，直至操作成功（譬如补充库存），或者被人工介入终止。**由此可见，可靠消息队列方式只要第一步成功了，后续就没有失败回滚的概念，只许成功，不许失败**。

可靠消息队列模型虽然能保证最终结果的相对可靠性，过程也足够简单，但整个过程完全没有隔离性可言。

以上这种依靠持续重试来保证可靠性的解决方案在计算机的其他领域中也被频繁使用，它还有专有的名称 —— “最大努力交付（Best-Effort Delivery）”。

可靠事件队列还有一种更普遍的形式，被称为“最大努力一次提交（Best-Effort 1PC）”，指的是**将最有可能出错的业务以本地事务的方式完成后，采用不断重试的方式来促使同一个分布式事务中其他关联的业务全部完成**。

[^1]: 参见 https://queue.acm.org/detail.cfm?id=1394128
