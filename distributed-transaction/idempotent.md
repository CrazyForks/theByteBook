# 5.4 系统幂等性设计

幂等性最初是一个数学概念，后来被引入计算机科学中，通常用来描述某个操作可以安全地重试，即多次执行的结果与单次执行的结果完全一致。

由于柔性事务普遍基于“最大努力交付”机制，也就是采用重复尝试的方式应对分布式系统随时可能出现的故障（如网络通信故障、节点宕机、用户重复操作等）。因此，如果系统不具备幂等性，重复处理可能会导致数据不一致或引发其他潜在风险。例如，在一个退款接口中，如果接口没有幂等性，多次请求可能会导致重复退款。



常见的幂等性设计方案有两种：使用唯一性约束（区分出第一次请求）、使用乐观锁。


## 5.4.1 使用全局唯一 ID
实现系统的幂等性有多种方式，最常用的是：**使用全局唯一 ID 方案**。

这种方案利用全局唯一 ID 及数据库主键唯一特性解决重复提交的问题，对于相同的 ID 重复插入时，产生 `result in duplicate entry for key primary` 错误，这种方式的流程如下。

:::center
  ![](../assets/id-service.png)
  图 5-5 使用全局唯一 ID 解决重复提交
:::

生成全局唯一 ID 最合适的是使用 snowflake（雪花算法，取自世界上没有两片相同的雪花之意），这是 Twitter 开源的分布式自增 ID 算法，使用分布式部署的情况下每秒可生成百万个不重复、递增 id。

另外一种方式是Token 机制，这种方式和`全局唯一ID`有点类似，不过增加了一个校验 `Token` 是否有效的逻辑，笔者以一个订单系统举例说明。

1. 订单系统提供一个发放 Token 令牌。Token 生成可以使用上面提到的 snowflake 算法生成。
2. 在订单页面，调用获取 token 接口，并对该 token 设定一个失效期。
3. 提交订单时，将该 token 作为参数提交给后端订单系统，后端判断该 token 是否存在：
	- 如存在，则为第一次提交，放行并删除 token
	- 如不存在，第二次提交，阻拦该请求

并发编程环境中，需要注意 token 的获取和删除要使用原子操作。

## 5.4.2 乐观锁

:::tip 什么是 ABA 问题
所谓的 ABA 问题是指在并发编程中，如果一个变量初次读取的时候是 A 值，它的值被改成了 B，然后其他线程又把 B 值改成了 A 值，而另一个早期线程在对比值时会误以为此值没有发生改变，但其实已经发生变化了，这就是 ABA 问题。
:::

先看一下数据库中幂等和非幂等性的操作。

幂等操作。
```plain
update order set price = 100 where id = 1;
```
非幂等。
```plain
update order set price = price+1 where id = 1;
```
并发操作数据库场景中，计算型更新会产生非幂等性问题。以支付环节为例，说明幂等性问题：

1. 用户下单一个 100 块钱的商品，在支付前与商家沟通这打个 9 折。
2. 但商家操作出错了，将价格改成了 8 折，改完后发现改错了，又重新修改成 9 折（数据库中最终价格是 ￥90）。
3. 但是由于网络出错或者别的原因，第一次修改通知产生了重试或者其他逻辑，覆盖了后面 ￥90 元的推送。
4. 最终，用户看到的待支付的价格，是错误的 ￥80 元。

对于这种典型的 ABA 问题，可以使用`乐观锁`来解决, 即在数据中加一个 version 或者 timestamp 之类的字段，以 version 举例的话就是每次修改的时候都先查出来要改的这个字段的版本号，然后再执行 SQL 语句进行修改，不过 SQL 中需要带一个 WHERE 子句，条件为 version = {查出来的版本}，如果是 UPDATE 语句的话则同时将版本号+1 。

我们看一下使用乐观锁的处理逻辑，如图 5-6 所示。

:::center
  ![](../assets/ABA.svg)
  图 5-6 使用乐观锁解决数据 ABA 问题
:::

从上面的流程图中，当商家第一次更新价格时，数据库更新成功，但因某些特殊原因，未能成功通知商家（也就是说没有拿到最新的 version），第二次更改价格时，由于本地的 version 已经失效，数据库会执行失败。这时候，只有产品逻辑上或刷新页面、或其用他方式，获取到最新的版本号才能继续修改。

上面的乐观锁，其实就是一种典型的 CAS（Compare And Swap | Compare And Set，比较并交换）操作。如果系统中冲突没那么频繁，倒是可以考虑这种简单的校验和后续处理来确保共享资源的一致性的方式。

## 5.4.3 分布式锁

