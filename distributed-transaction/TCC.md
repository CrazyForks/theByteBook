# 5.3.2 TCC

TCC（Try，Confirm，Cancel）事务模型来源于 Pat Helland 发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》论文[^1]。TCC 提出了一种新的事务模型：基于业务层面的事务定义，锁粒度完全由业务自己控制。目的是解决复杂业务中，跨表跨库等大颗粒度资源锁定的问题。

TCC 是一种对业务侵入性较强的事务方案，要求业务处理过程中必须拆分为“预留业务资源”、“确认/释放消费资源”两个子过程，两个子过程细化为如下三个阶段：

1. **Try 阶段**：尝试执行阶段，完成所有业务可执行检查（预留必须业务资源，保障隔离性）。
2. **Confirm 阶段**：如果所有分支的 Try 都成功了，则走到 Confirm 阶段。Confirm 真正执行业务，使用 Try 阶段预留的业务资源来完成处理。
3. **Cancel 阶段**：如果所有分支的 Try 有一个失败了，则走到 Cancel 阶段，释放 Try 阶段预留的业务资源。

按照 TCC 的协议规定，Confirm 和 Cancel 阶段只返回成功，不会返回失败，如果由于网络问题或者服务器临时故障，那么事务管理器会进行重试直至最终成功，**所以这两个阶段的操作要求具备幂等性**。

这里，我继续以前篇下单的过程为案例，说明 TCC 事务处理流程，不过我们稍微简化下逻辑，案例中去除不那么重要的积分服务，只保留支付、仓库服务。

:::center
  ![](../assets/TCC.svg)<br/>
  图 5-3 TCC 事务模型
:::

1. 用户向商店发送一个交易请求，如购买价值 ￥100 的某个商品。
2. 创建事务，生成事务 ID，记录在活动日志中，进入 Try 阶段。
	- 支付服务：检查业务可行性，若可行，将用户的 100 元设置为冻结状态，通知下一步进行 Confirm 阶段；若不可行，通知下一步进入 Cancel 阶段。
	- 仓库服务：检查业务可行性，若可行，将仓库该商品的其中一条库存设置为冻结状态，通知下一步进行 Confirm 阶段；若不可行，通知下一步进入 Cancel 阶段。
3. 如果以上所有业务反馈业务可行，将活动日志中的状态记录为 Confirm，进入 Confirm 阶段。
	- 支付服务：完成业务操作，扣减之前冻结的 100 元。
	- 仓库服务：完成业务操作，标记之前冻结的库存为出库状态，并扣减库存。
4. 如果第 3 步全部正常完成，则整个事务顺利结束，如果第 3 步任意一方出现异常，将根据活动日志中的记录，重复执行异常方的 Confirm 阶段，进行最大努力交付尝试。
5. 如果第 2 步有任意业务方反馈业务处理失败，则将活动日志状态记为 Cancel，进入 Cancel 阶段。
	- 支付服务：取消业务操作，释放被冻结的 100 元。
	- 仓库服务：取消业务操作，释放被冻结的库存。
6. 如果第 5 步全部完成，事务宣告以失败回滚结束，如果第 5 步中有任何异常，将根据活动日志中的记录，重复执行异常方的 Cancel 阶段，进行最大努力交付尝试。


由上述操作过程可见，TCC 其实有点类似 2PC 的准备阶段和提交阶段，本质是把数据库的二阶段提交上升到微服务来实现，从而避免数据库二阶段中长事务引起的低性能风险。

所以说，TCC 解决了跨服务的业务操作原子性问题，比如下订单减库存，多渠道组合支付等场景，通过 TCC 对业务进行拆解，可以让应用自己定义数据库操作的粒度，可以降低锁冲突，提高系统的业务吞吐量。

[^1]: 参见 http://adrianmarriott.net/logosroot/papers/LifeBeyondTxns.pdf