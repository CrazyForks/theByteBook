# 10.1 什么是 GitOps

先来看一个传统的云原生应用如何持续交付。

图 10-1 展示了一个传统的 Push（主动推进）交付模型。该模型包括以下步骤，开发人员提交代码、触发 Jenkins 构建任务、使用 SonarQube 检测代码质量、利用 Docker 构建镜像、将镜像推送至镜像仓库、使用 Helm 打包服务配置、最后将应用部署到 Kubernetes 集群。

:::center
  ![](../assets/cicd-push.png)<br/>
  图 10-1 Push 交付模型
:::

上述流程做好自动化以后，看起来也没什么问题。但认真思考，会发现 Push 交付模型中的**流程都是从左往右推进**。如果是云原生应用（用 yaml 文件描述，并将配置存储在仓库中的应用），随着时间的推移会出现下面问题：

- 很难保证配置描述的状态和云原生底座（如 kubernetes 集群）中的运行状态真正相符。时间长了，容易发生“配置漂移”情况，即配置的期望状态和真正的运行状态不相符；
- 随着服务规模不断扩大，工程师们疲于应对**线上和配置状态不一致**问题。因为人工操作 kubectl，无法追溯、不可回源等，还产生各类**安全合规**问题。

你是否还能想起本书第一章关于声明式的介绍。

:::tip 声明式设计要点
我们向一个工具描述我们想要让一个事物达到的目标状态，由这个工具自己内部去解决如何令这个事物达到目标状态。
:::

云原生应用的部署底座是 Kubernetes，Kubernetes 是一种声明式系统，它使用 yaml 来定义系统的最终状态应该是什么样子。如果把这些描述应用状态的 yaml 文件存储在 Git 仓库中，再实现 git 仓库中配置和集群状态自动同步的机制。如图 10-2 所示，一种以声明式系统为基座、以 Git 为单一可信源的新型交付模型出现了。

:::center
  ![](../assets/gitops.svg)<br/>
  图 10-2 GitOps 中的应用同步模型
:::

## 10.1.2 GitOps 的实施流程