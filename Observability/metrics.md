# 9.2.1 聚合指标

作为传统监控和告警领域的代名词，Metrics 最广为人知，也被各类可观测系统支持的最丰富。Metrics 一般是用来计算 Events 发生数量的数据集，例如服务 QPS、API 响应延迟、某个接口的失败数等。它们大部分都是以数字化指标出现，特征是可聚合性，在数据的处理上，Metrics 可以是实时的，也可能是区间范围的，是跟随着时间变化的时序数据。既能做常见的监控告警，也可以用来做趋势分析。

- 实时监控和警报，Metrics 常见的用于是看板，并在系统在超过阈值或者行为异常时自动触发报警。
- 趋势分析：Metrics 还用在趋势分析，同时还可以在事件发生后提供历史数据分析，修复或者监控以防止潜在问题再次发生。

由于目前并没有 Metrics 采集的标准 API，所以不同的监控系统在收集 Metrics 数据时采取的手段也可能不一样，但大部分无非都是通过 PUSH 到中心 Collector 方式采集 Metrics（比如各种 Agent 采集器，Telegraf 等）； 又或者是中心 Collector 通过 PULL 的方式去主动获取 Metrics（比如 Prometheus）。


时序数据库

TSDB 是专门用来存储随时间变化的数据，如股票价格、传感器数据等。时间序列（time-series）的是某个变量随时间变化的所有历史，而样本 （sample）指的是历史中该变量的瞬时值。


时序数据一般有以下几个显著特点：

- 每条数据必然自带时间戳，数据以时间排序
- 不可变性（immutable）：一旦写入，基本不做修改或单条删除。（因为老化过期可以做删除）
- 数据量大，一般要求支持PB级别。同时也要求高吞吐能力。
- 高效的存储压缩效率，降低成本
- 时序最核心的用途在于数据分析，包括降采样、数据插值和空间聚合计算等
- 时序的唯一性：某一个时刻的某个指标只有一条数据（或点），即时出现多条数据也会被认为是同一条数据（或点）
- 单条数据并不重要

## 存储

回到我们的主角 Prometheus， 它会将所有采集到的样本（sample）数据以时间序列（time-series）的方式保存在内存数据库中，并且定时保存到硬盘上。时间序列是按照时间戳和值的序列顺序存放的，每条time-series通过指标名称（metrics name）和一组标签集（labelset）命名。

主流的 TSDB 包括了 InfluxDB、Prometheus、Kdb、Graphite、TimescaleDB、Apache Druid 等等。
为了追求极致性能和极致成本，大家都在针对海量数据和使用场景，持续改进和优化数据的存储结构设计、各种高效索引机制、和查询效率。从单点技术或者关键技术上来讲，有趋同性和同质化的大趋势


Metrics 提供的信息可用于系统整体行为和监控状况的分析，它不一定能揭示问题根本原因，但可以作为发现问题的起点。一个典型例子是你收到一条告警”请求成功率跌到了 10%“，你意识到不妙，立即开始处理，然后结合其他 Signals 去找到 root cause，从而解决问题。

prometheus-vs-victoriametrics[^1]

||Prometheus| VictoriaMetrics | 
|:--|:--|:--|
|数据采集	 |基于拉动	|基于拉式和推式|
|数据摄取	 |每秒高达 240,000 个样本|	每秒高达 360,000 个样本|
|数据查询 |	每秒高达 80,000 次查询	|每秒高达 100,000 次查询|
|内存使用情况	|高达 14GB RAM	|高达 4.3GB 的 RAM|
|数据压缩	 |使用LZF压缩	| 使用 Snappy 压缩|
|磁盘写入频率|	更频繁地将数据写入磁盘	|减少将数据写入磁盘的频率|
|磁盘空间使用情况	|需要更多磁盘空间	|需要更少的磁盘空间|
|查询语言	|PromQL	|MetricsQL（向后兼容 PromQL）|

时序数据库排名

https://db-engines.com/en/ranking/time+series+dbms

## 告警

[^1]: 参见 https://last9.io/blog/prometheus-vs-victoriametrics/