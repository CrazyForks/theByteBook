# 9.3.4 性能剖析 Profiling

熟悉 Golang 的工程师对 pprof 工具一定不陌生。借助 pprof 提供的 CPU 和内存分析功能，工程师能够深入了解 Golang 函数的执行时间、内存使用情况，从而分析、优化软件性能。

可观测性领域内的性能剖析（Profiling）的目标与 Golang 中的 pprof 类似，两者皆是对运行中应用动态分析、生成详细的运行数据（Profiles），帮助工程师全面了解软件资源使用情况，确定代码和性能瓶颈之间的关联。

Profiles 数据通常以火焰图、堆栈图或内存分析图等形式呈现，是从“是什么”到“为什么”这一过程中重要的依据。例如，通过链路追踪识别出延迟（是什么）的位置，然后根据火焰图进一步定位到具体的代码行（为什么）。2021 年，国内某网站崩溃，工程师分析火焰图发现 Lua 代码存在异常，最终成功定位到问题源头[^1]。

:::center
  ![](../assets/lua-cpu-flame-graph.webp)<br/>
  图 9-16 Lua 代码的 CPU 火焰图
:::

:::tip 火焰图分析说明

火焰图颜色没有特殊含义，因为火焰图表示的是 CPU 的繁忙程度，所以一般选择暖色调。

- 纵轴表示调用堆栈深度，越往上表示调用链越深，调用顺序依次向上。最底层的横向条形表示最开始的调用（通常是主函数或入口函数），每一层之上的条形表示被下层函数调用的函数。
- 横轴表示某个函数在采样期间占用的时间比例（宽度越大，表示消耗时间越长）。

分析火焰图的关键是观察横向条形的宽度，宽度越大表示该函数占用的时间越多。一旦出现“平顶”，则可能意味着该函数存在性能瓶颈。

:::

Profiles 数据包括多种类型，由不同的分析器（Profiler）生成，常见分析器如下：

- **CPU 分析器**：用于分析哪些函数或方法在运行时消耗了最多的 CPU 时间。例如，通过 CPU Profiler，我们可以确定某个算法的优化是否减少了 CPU 使用率。
- **堆分析器（Heap Profiler）**：用于监测程序的内存使用情况，帮助发现内存泄漏或不必要的内存分配。例如，在 Java 应用中，Heap Profiler 可以帮助找到导致内存溢出的具体对象或数据结构。
- **GPU 分析器**：用于分析图形处理单元（GPU）的利用情况，常用于游戏开发或图形密集型应用。
- **互斥锁分析器**：用于检测互斥锁的竞争情况，帮助优化多线程程序的并发性能。
- **I/O 分析器**：分析 I/O 操作的性能，如用来分析文件读写操作的延迟或网络请求的耗时，从而优化数据传输效率。
- **特定编程语言的分析器**：如 JVM Profiler，专门分析运行在 Java 虚拟机上的应用程序。

过去，由于分析器资源消耗较高，工程师通常仅在紧急情况下临时启用它们。随着低开销分析技术的兴起，如编程语言层面的 Java Flight Recorder 和 Async Profiler 技术、操作系统层面的 systemTap 和 eBPF 技术，让生产环境中的“持续性能分析”（Continuous Profiling）逐渐成为现实，捕获“疑难杂症”的现场快照也变得更加容易。

[^1]: 参见《2021.07.13 我们是这样崩的》https://www.bilibili.com/read/cv17521097/

