# 6.3.2 Paxos 算法

希望你没有对前篇 Paxos 的“复杂”做的铺垫所吓倒，共识问题已经算是一个古老的领域，30 余年间已经有无数简洁直白的视频、论文等资料进行过解读。网络中流传甚广的 raft 和 paxos 视频讲解[^1]，即使没有多少技术背景，也能通俗地理解 Paxos。


## 1. Paxos 算法背景

在 Paxos 算法中，节点分为三种角色。

- **提议者（Proposer）**：提议者是启动共识过程的节点，它提出一个值，并请求其他节点对这个值进行投票，提出值的行为被称为“提案"（Proposal），提案包含提案编号 (Proposal ID) 和提议的值 (Value)。注意的是，Paxos 算法是一个典型的为“操作转移”模型设计的算法，为简化表述，本文把提案类比成“变量赋值”操作，但你应该理解它是“操作日志”相似的概念，后面介绍的 Raft 算法中，直接就把“提案”称做“日志”了。
- **决策者（Acceptor）**：接受或拒绝 Proposer 的提案，如果一个提案被超过半数的 Acceptor 接受，那提案意味着被“批准”（accepted）。提案一旦被批准，意味着在所有节点中达到共识，便不可改变、永久生效。
- **记录者（Learner）**：记录者发不起提案，也不参与决策提案，但它们需要学习并知道哪些提案被接受作为最终决策。

在 Paxos 算法中，节点都是平等的，它们都可以承担一种或者多种角色。例如，一个节点即可发起提案，也可以就一个提案进行表决，但为了Quorum 的计算更加明确，表决提案的角色最好要有奇数个。

Paxos 是基于 Quorum 的算法，仅依靠“数服从多数原则”，一定会遇到提案冲突的问题。如图 6-5 所示，S~1~ 看到其他服务器没有接受某个值，之后提出 red 值。S~5~ 也没有看到其他服务器接受某个值，于是提出 blue 值。它们的提案 Quorum 都达成了，也就是说一个提案有两个值选中，这显然破坏了一致性原则。

:::center
  ![](../assets/paxos_2pc_choice.png) <br/>
  图 6-5 网络延迟导致冲突
:::

注意，你会发现矛盾点在于 S~3~，S~3~ 是两个多数派中的交集点，它的时间线上有两个不同的值被选中，这实际上是一个“并发”操作问题。

我们知道，程序设计中的一个基本常识是：多个线程并发操作一个共享变量，一定要加上互斥锁，不然会出现各种意外情况。所以，S~3~ 的问题本质是：“在分布式环境下并发操作共享变量的问题”。

我们不能简单“套用”进程加锁的方式，分布式环境下可能随时会出现通信故障，如果一个节点获得锁之后，释放锁之前故障了，整个系统都会被无限期等待阻塞。因此，必须提供一种可供其他节点抢占锁的机制，避免因通信故障出现的死锁问题。分布式抢占锁的设计思想和 5.4.2 节提到的“乐观锁”有“异曲同工之妙”。回顾乐观锁的示例 SQL，WHERE 条件的作用是判断在它操作之前，数据是否被修改。如果修改过，则请求最新的数据，更新版本号，然后用重试的方式再次修改。

```SQL
UPDATE accounts 
SET balance = balance + ?, 
    version = version + 1 
WHERE id = ? AND version = ?;
```

我们延续“乐观锁”的思路，我们讨论图 6-7 所示的因延迟导致的冲突如何解决。S~1~ 发起提案，S~3~ 收到 S~1~ 提案时，应该意识到 blue 的 Quorum 达成，S~1~ 的提案 red 太老。所以，为了提案达成一致，S~1~ 应该更新提案，把 red 修改为 blue（相当于乐观锁中的操作失败，请求最新数据），然后再次重试。


## 2. Paxos 算法描述

相信通过以上铺垫，你已经具备了足够的前置知识来理解 Paxos 算法。简而言之，Paxos 算法本质上是一个支持多次提案的二阶段提交协议。

Paxos 算法的第一个阶段称“准备阶段”（Prepare）。该阶段相当于提案的抢占，Proposer 选择一个提案编号 $\mathit{n}$（通常是单调递增的数字，相当于乐观锁中的 version，更高的编号意味着更高的优先级），向所有的 Acceptor 广播一个许可申请（称为 $\mathit{Prepare(n)}$ 请求），如果 Acceptor ：
- 尚未承诺 $\mathit{≥n}$ 编号的提案：则“承诺”（promise）不再接受任何编号小于 𝑛 的提案，返回一个响应，其中包含承诺的提案编号以及对应的提案值（如果有）；
- 已承诺 $\mathit{≥n}$ 编号的提案：拒绝当前的 Prepare 请求，不返回任何响应。

Proposer 从多数（Quorum）Acceptor 获得了“承诺”（Promise），则“准备阶段”达成。接着，Proposer 选择提案值：如果 Acceptor 的响应中返回了提案值，从中选择编号最高的提案值；如果没有返回的提案值，则使用 Proposer 自己设定的初始提案值。

完成以上操作后，Proposer 进入下一个阶段。

Paxos 算法的第二个阶段称“批准阶段”（Accept）。在该阶段，Proposer 向所有 Acceptor 广播一个批准申请（称为 $\mathit{accept(n, v)}$ 请求），请求批准：“提案编号 $\mathit{n}$ 提案值 $\mathit{v}$”。如果 Acceptor 发现提案编号 不小于它已承诺的最大编号，则“批准”（accepted）该提案；否则，Acceptor 拒绝该提案。当多数（Quorum）的 Acceptor 批准提案时，Proposer 认为本轮提案成功。一旦提案成功，Proposer 会将最终的决议广播给所有 Learner 节点，供它们学习并记录最终结果。

:::center
  ![](../assets/paxos.svg) <br/>
  图 6-6 Basic Paxos 流程
:::

## 3. Paxos 算法验证

Paxos 难以理解是指其推导过程复杂，证明 Paxos 的正确性比重新实现 Paxos 算法还难。我们没必须推导 Paxos 的正确性，通过以下几个例子来验证 Paxos 算法的运行机制。

下面的示例中，X、Y 代表客户端，S~1~ 到 S~5~ 是服务端，它们既是 Proposer 又都是 Acceptor，图中的 P 代表 “Prepare 阶段”，A 代表“Accept 阶段”。这里为了防止重复，Proposer 提出的编号 n 由两部分组成：自增序号.Server ID。例如，S~1~ 提出的提案编号，就是 1.1、2.1、3.1...。

下面我们分析它们就一个“提案选取值 X 还是 Y ”进行决议，会出现什么情况。

**情况一：提案已批准**。如图 6-7 所示，S~1~ 收到客户端的提案 X，于是 S~1~ 作为 Proposer，向 S~1~...S~3~ 广播 Prepare(3.1) 请求，由于 Acceptor S~1~...S~3~ 没有接受过任何提案，所以接受该提案。接着，Proposer S~1~ 广播 Accept(3.1, X) 请求，提案 X 成功被批准成为决议。

在提案 X 被批准后，S~5~ 收到客户端的提案 Y，S~5~ 向 S~3~...S~5~ 广播 Prepare(4.5) 请求。对 S~3~ 来说，4.5 比 3.1 大，且已经接受了 X，它会回复提案 (3.1, X)。S~5~ 收到 S~3~...S~5~ 的回复后，使用 X 替换自己的 Y，于是广播 Accept(4.5, X) 请求。S~3~...S~5~ 接受提案。最终所有 Acceptor 达成一致，都拥有相同的值 X。

:::center
  ![](../assets/paxos-p1.png) <br/>
  图 6-7 提案已批准
:::

**情况二：事实上，对于情况一，也就是“取值为 X”并不是一定需要多数派批准，S~5~ 发起提案时，Prepare 阶段的应答中是否包含了批准过 X 的 Acceptor 也影响决策**。如图 6-8 所示，S~3~ 接受了提案 (3.1, X)，但 S~1~、S~2~ 还没有收到 Accept(3.1, X) 消息。此时 S~3~、S~4~、S~5~ 收到 Prepare(4.5) 消息，S~3~ 会回复已经接受的提案 (3.1, X)，S~5~ 将提案值 Y 替换成 X，广播 Accept(4.5, X) 消息给 S~3~、S~4~、S~5~，对 S~3~ 来说，编号4.5 大于 3.1，所以会接受这个提案，最终共识的结果仍然是 X。

:::center
  ![](../assets/paxos-p2.png) <br/>
  图 6-8 提案部分接受，新 Proposer 可见
:::

**情况三：另外一种可能的情况是 S~5~ 发起提案时 Prepare 阶段的应答中未包含批准过 X 的决策节点**。S~1~ 接受了提案 (3.1, X)，S~3~ 先收到 Prepare(4.5)，后收到 Accept(3.1, X)，由于 3.1 小于 4.5，会直接拒绝这个提案。所以提案 X 无法收到超过半数的回复，这个提案就被阻止了。提案 Y 顺利通过，整个系统最终对“取值为 Y”达成一致。

:::center
  ![](../assets/paxos-p3.png) <br/>
  图 6-9 提案部分接受，新 Proposer 不可见
:::


**情况四：从情况三可以推导出另一种极端的情况**，两个或多个 Proposer 同时发起提议，在 Prepare 阶段互相抢占，反复刷新 Acceptor 上的提案编号，导致任何一方都无法达到多数派决议，这个过程理论上可以无限持续下去，形成活锁（livelock）。

解决这个问题并复杂，是把重试时间进行一些随机化，减少这种巧合发生。
:::center
  ![](../assets/paxos-p4.png) <br/>
  图 6-10 出现活锁问题
:::

Paxos 算法的的价值在于扩展了分布式共识算法的发展思路，但它有以下缺陷：只能对决议一个提案，决议形成至少需要两次网络来回，高并发情况还有可能形成活锁。因此，Basic Paxos 几乎只是用来做理论研究，并不直接应用在实际工程中。后来，Lamport 在“Paxos Made Simple” 论文中，针对多次提案和大规模分布式系统中的实际需求，提出了 Paxos 的优化变体 Multi Paxos。Multi Paxos 的思想是增加“选主”机制，通过多次运行 Paxos 算法来处理一系列提案。

不过，Lamport 的论文主要关注的是 Paxos 的算法基础和正确性证明，对于领导者选举以及解决多轮提案的效率问题，并没有给出充分的实现细节。2014 年，斯坦福的学者 Diego Ongaro 和 John Ousterhout 发表了论文《In Search of an Understandable Consensus Algorithm》，该论文基于 Multi-Paxos 思想上，提出了简化和改进版的 Raft 算法。Raft 算法明确提出了“选主”、“日志复制”等概念以及实现细节的描述。该论文斩获 USENIX ATC 2014 大会 Best Paper 荣誉，Raft 算法更是成为 etcd、Consul 等分布式系统的实现基础。


[^1]: 讲解作者是斯坦福教授 John Ousterhunt，他还指导了 Diego Ongaro 写出了 Raft 的论文。本章配图也多来源于 John Ousterhunt 所发表的内容。
[^2]: 参见 https://lamport.azurewebsites.net/pubs/time-clocks.pdf
