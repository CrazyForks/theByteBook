# 6.3.2 Basic Paxos

希望你没有对前篇 Paxos 的“复杂”做的铺垫所吓倒，共识问题已经算是一个古老的领域，30 余年间已经有无数简洁直白的视频、论文等资料进行过解读。譬如在网络中流传甚广的 raft 和 paxos 视频讲解[^1]，即使没有多少技术背景，也能通俗地理解 Paxos。


实现多个节点 x 值一致的复杂度主要来源于以下两个因素的共同影响：

- 分布式系统是不可靠的：节点可能宕机，节点间通信可能延迟、丢失、乱序；
- 操作是并发的：如果是串行操作，单纯使用少数服从多数原则，就足以保证正确读写数据。但并发操作就变成了“**分布式环境下多个节点并发操作共享数据**”的问题。

第一问题相对好解决。一个节点不可靠无所谓，只要一群节点中多个节点可靠就行。按照少数服从多数原则，也就是 Quorum 机制。

:::tip Quorum

Quorum（法定人数）指的是在一个分布式系统中，能够进行合法决策所需的最小节点数，也就是集群节点总数的一半加一（即 ⌈N/2⌉ + 1，其中 N 是集群节点总数）。Quorum 的大小决定了系统的容错能力，一个集群最多能容忍 ⌊N/2⌋ 个节点失效。例如：
- 3 节点集群：Quorum 为 2，允许 1 个节点失效；
- 5 节点集群：Quorum 为 3，允许 2 个节点失效。

如果失效节点超过 ⌊N/2⌋，系统无法形成 Quorum，集群就会停止提供服务以避免一致性问题。
:::


但是问题还是存在：**每个决策节点该接受几个提案呢**? 

先看第一种情况：**按时序决策节点只接受它收到的第一个提案**。但考虑多个提议节点同时对一个提案进行提议，最后可能没有一个提议能够取得多数的投票，出现了平票问题（Split Votes）。如图 6-5 所示，red 和 blue 各有 2 票，没办法确定谁被选择？这也就意味着我们无法保证在一轮投票中达成共识，这违背活性（Liveness）要求。

:::center
  ![](../assets/paxos_split_votes.png) <br/>
  图 6-5 多个决策节点会遇到平票问题
:::

再看第二种情况：**决策节点就需要允许接受多个不同的提案，用多数派的机制解决平票问题问题**。但新的问题是有了少数服从多数原则，就会碰到冲突的问题。如图 6-6 所示，不同提案节点提议不同的值，可能都会被选择（S~3~ 收到了 blue 和 red，S~3~ 该确认选择哪个值？ ），这就破坏了每个提案只有一个值的原则，这违背了安全性（Safety）要求。

:::center
  ![](../assets/paxos_conflict_choices.png) <br/>
  图 6-6 接受多个不同的提案会遇到冲突问题
:::

:::tip 注意，Paxos 强调
Once a value has been chosen, future proposals must propose the same value.
:::

也就是说，我们讨论的 Basic-Paxos 只会 Chosen 一个值。基于此，就需要一个两阶段（2-phase）协议，对于已经 Chosen 的值，后面的提案要放弃自己的提议，提出已经被选中的值。例如，S~5~ 发起提案之前，先广播给 S~3~、S~4~、S~5~ 这 3 个节点，询问是否已经有接受的提案，如果已有，则撤销自己的提案，S~5~ 的题案由 blue 改为 red，这一阶段在 Basic Paxos 称为准备（Prepare）阶段。

:::tip 第一阶段实际是分布式抢占锁的过程

如果并发操作一个变量不使用锁，会出现各种意外情况，假设有一个变量 x 在当前系统存储的值是 2，同时有外部请求 A、B 分别对系统发送操作指令，把 x 的值加 1 和 把 x 值乘 3，如果不加任何控制，将可能得到 `(2+1)*3=9` 或者`（2*3+1）=7`。

到了分布式环境下，由于要考虑到分布式系统内可能任何时刻出现的通信故障，如果一个节点取得锁之后、释放锁之前发生故障，这将导致整个系统被无限期的等待所阻塞，因此分布式环境中的加锁就不能完全等同于单机系统并发控制中以互斥量实现的加锁，还要提供一个其他节点能抢占锁的机制，以避免因通信问题出现死锁。

:::

仅单纯使用二阶段协议仍然无法解决这个问题，分布式系统中的网络延迟无法忽视。如图 6-7 所示，S~1~ 和 S~5~ 在第一个阶段都发现没有其他的值被选中，因此提出自己的提案，但在这个时序下会有两个不同的值被选中。

:::center
  ![](../assets/paxos_2pc_choice.png) <br/>
  图 6-7 网络延迟导致冲突
:::

所以你会发现，矛盾的点其实就是这个 S~3~，也就是少数服从多数原则，能保证任意的大多数都是有交集的。交集中的点会发现矛盾（和之前接受的值有矛盾理应选择拒绝）。

:::tip 思考：3 个节点的容忍度是 1，那么 4 节点的容忍度是多少？

答案也是 1，因为要形成发现矛盾的交集对于 4 来说，要达到 3/4，才能构成大多数，这就是为什么集群选单数的原因，因为双数从算法的角度来说没什么帮助。
:::

如图 S~3~ 应该拒绝 S~1~ 的提案，这样就可以保证 S~5~ 的提案成功，S~1~的提案因为冲突而失败。这种方式我们需要对提案进行排序，有了排序，决策节点就可以拒绝老的提议。如果你熟悉分布式系统，应该能想到《Time, Clocks and the Ordering of Events in a Distributed System》[^2] 这篇论文，我们不能简单用时间来判断提案的先后顺序。


## 1. Basic Paxos 算法描述


“准备阶段”（Prepare）相当于抢占锁的过程。某个提案节点准备发起提案，必须先向所有的决策节点广播一个许可申请（称为 Prepare 请求）。Prepare 请求附带一个全局唯一且单调递增的数字 n 作为提案 ID。决策节点收到请求后，将给予提案节点两个承诺与一个应答：
- [承诺1]：不再接受提案 ID <= n 的 Prepare 请求；
- [承诺2]：不再接受提案 ID < n 的 Accept 请求；
- [应答]：不违背历史承诺的前提下，回复形成决议最大的那个提案所设定的值和提案 ID：
  - 如果这个值没有被任何提案设定过，则返回空值
  - 如果违反历史承诺，即收到的提案 ID 并不是决策节点收到的最大的 ID，对 Prepare 请求不予理会。

提案节点收到多数决策节点的应答（称为 Promise 应答）后，就可以开始“批准”（Accept）阶段了。

提议者向所有接受者广播 accept(n, v) 请求，请求接受提案编号为 n 和提案值为 v。
- 如果提案编号 n >= 该接受者之前所承诺的编号，它将接受该提案，并返回 accepted(n, v) 消息。
- 如果提案编号 n < 该接受者所承诺的编号，它将拒绝该提案。

如果提案节点收到了大多数决策节点的应答（accepted），协商结束，共识协议形成，然后将形成的决议发送给所有记录节点进行学习。


:::center
  ![](../assets/paxos.svg) <br/>
  图 6-8 Basic Paxos 流程
:::

## 2. Basic Paxos 验证

那这样的二阶段提交算法是否可以解决前面提到的问题？我们通过具体的例子来分析。

假设共有五个节点 S~1~、S~2~、S~3~、S~4~、S~5~，这 5 个节点同时扮演着提案节点和决策节点的角色。此时，有两个并发请求希望将同一个值分别设定为 X（由 S~3~ 作为提案节点提出）和 Y（由 S~5~ 作为提案节点提出），图中的 P 代表准备阶段，A 代表批准阶段，这时会发生以下几种情况。

**情况一：提案已 Chosen** 譬如，S~1~ 选定的提案 ID 是 3.1（全局唯一 ID 加上节点编号），先取得了多数派决策节点的 Promise 和 Accepted 应答，此时 S~5~ 选定提案 ID 是 4.5，发起 Prepare 请求，收到的多数派应答中至少会包含 1 个此前应答过 S~1~ 的决策节点，假设是 S~3~，那么 S~3~ 提供的 Promise 中必将包含 S~1~ 已设定好的值 X，S~5~ 就必须无条件地用 X 代替 Y 作为自己提案的值，由此整个系统对“取值为 X”这个事实达成一致。整个流程如下图所示。

:::center
  ![](../assets/paxos-p1.png) <br/>
  图 6-9 提案已 Chosen
:::

**情况二：提案未 Chosen，Proposer 可见** 事实上，对于情况一，X 被选定为最终值是必然结果，但从上图中可以看出，X 被选定为最终值并不是必定需要多数派的共同批准，只取决于 S~5~ 提案时 Promise 应答中是否已包含了批准过 X 的决策节点，譬如图 6-3 所示，S~5~ 发起提案的 Prepare 请求时，X 并未获得多数派批准，但由于 S~3~ 已经批准的关系，最终共识的结果仍然是 X。

:::center
  ![](../assets/paxos-conflict-2.png) <br/>
  图 6-10 提案未 Chosen，Proposer 可见
:::

**情况三：提案未提交，Proposer 不可见** 当然，另外一种可能的结果是 S~5~ 提案时 Promise 应答中并未包含批准过 X 的决策节点，譬如应答 S~5~ 提案时，节点 S~1~ 已经批准了 X，节点 S~2~ 、S~3~ 未批准但返回了 Promise 应答，此时 S~5~ 以更大的提案 ID 获得了 S~3~、S~4~、S~5~ 的 Promise，这 3 个节点均未批准过任何值，那么 S~3~ 将不会再接收来自 S~1~ 的 Accept 请求，因为它的提案 ID 已经不是最大的了，这 3 个节点将批准 Y 的取值，整个系统最终会对“取值为 Y”达成一致，如图下图所示。

:::center
  ![](../assets/paxos-conflict3.png) <br/>
  图 6-11 提案未提交，Proposer 不可见
:::

**情况四：出现活锁**

从情况三可以推导出另一种极端的情况，如果 2 个提案节点交替使用更大的提案 ID 使得准备阶段成功，但是批准阶段失败的话，这个过程理论上可以无限持续下去，形成活锁（Live Lock）。例如 S~3~、S~4~、S~5~ 拿着更高的提交号导致 S~1~、S~2~、S~3~ 的 accept 被拒绝重新进行提交，又把 S~3~、S~4~、S~5~ 给拒绝了，提议者没有看到先前提议的情况下，当 S~1~ 发现自己的提议没有通过，就会发起新一轮 Prepare RPC，然后就有可能又封锁了 S~5~ 的提议，S~5~ 又会回到 Prepare 阶段，有概率双方都轮流封锁对方的协议，导致无法达成共识。

:::center
  ![](../assets/paxos-liveness.png) <br/>
  图 6-12 出现活锁问题
:::

解决这个问题的办法就是把重试时间进行一些随机化，减少这种巧合发生，或者把重试的时间指数增长等等。

总结 Paxos 中保证一致性的最核心的两个原则其实就是**少数服从多数**和**后者认同前者**。Paxos Basic 只能对一个值形成决议，而且决议形成至少需要两次网络来回，高并发情况还有可能形成活锁，因此 Basic Paxos 几乎只是用来做理论研究，并不直接应用在实际工程中。

[^1]: 讲解作者是斯坦福教授 John Ousterhunt，他还指导了 Diego Ongaro 写出了 Raft 的论文。本章配图也多来源于 John Ousterhunt 所发表的内容。
[^2]: 参见 https://lamport.azurewebsites.net/pubs/time-clocks.pdf
