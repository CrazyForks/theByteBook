# 10.6 GitOps 


先来看一个传统的云原生应用如何持续交付。

图 10-1 展示了一个传统的 Push（主动推进）交付模型。该模型包括以下步骤，开发人员提交代码、触发 Jenkins 构建任务、使用 SonarQube 检测代码质量、利用 Docker 构建镜像、将镜像推送至镜像仓库、使用 Helm 打包服务配置、最后将应用部署到 Kubernetes 集群。

:::center
  ![](../assets/cicd-push.png)<br/>
  图 10-1 Push 交付模型
:::

上述流程做好自动化以后，看起来也没什么问题。但认真思考，会发现 Push 交付模型中的**流程都是从左往右推进**。如果是云原生应用（用 yaml 文件描述，并将配置存储在仓库中的应用），随着时间的推移会出现下面问题：

- 很难保证配置描述的状态和云原生底座（如 kubernetes 集群）中的运行状态真正相符。时间长了，容易发生“配置漂移”情况，即配置的期望状态和真正的运行状态不相符；
- 随着服务规模不断扩大，工程师们疲于应对**线上和配置状态不一致**问题。因为人工操作 kubectl，无法追溯、不可回源等，还产生各类**安全合规**问题。

你是否还能想起本书第一章关于声明式的介绍。

:::tip 声明式设计要点
我们向一个工具描述我们想要让一个事物达到的目标状态，由这个工具自己内部去解决如何令这个事物达到目标状态。
:::

云原生应用的部署底座是 Kubernetes，Kubernetes 是一种声明式系统，它使用 yaml 来定义系统的最终状态应该是什么样子。如果把这些描述应用状态的 yaml 文件存储在 Git 仓库中，再实现 git 仓库中配置和集群状态自动同步的机制。如图 10-2 所示，一种以声明式系统为基座、以 Git 为单一可信源的新型交付模型出现了。

:::center
  ![](../assets/gitops.svg)<br/>
  图 10-2 GitOps 中的应用同步模型
:::


实施 GitOps 由以下三个要素：

- **一切皆代码**：GitOps 的设计理念是将一切（基础设施、应用程序、服务状态等）代码化，然后使用 Git 对代码版本控制，有任何变更则通过 Git Push/Pull 处理。所以，GitOps 也被称为 IaC（Infrastructure as Code，基础设施即代码）+ Git + CI/CD。
- **Git 为单一可信源**：所有的变更都要从 Git 仓库侧发起，这样方便代码的安全和审计。 
- **声明式系统为基座**：以声明式系统（包括基础设施和应用程序）为基座（典型如 Kubernetes）。

GitOps 三要素下的 CI/CD 流程可以概括为图 10-3。

- 首先，团队成员 fork 仓库进行业务逻辑开发，然后提交 Pull Request。
- 接下来运行 CI 流水线，例如校验配置文件、执行自动化测试、构建镜像、推送到镜像仓库等。
- CI 流水线执行完成后，拥有合并代码权限的人将 Pull Request 合并到主分支。
- 合并的事件触发 CD 流水线，结合 CD 系统（例如 Argo CD）将变更自动应用到目标集群中。

:::center
  ![](../assets/gitops-workflow.webp)<br/>
  图 10-3 GitOps 下的 CI/CD 流程
:::

基于 Git 仓库作为集群状态的唯一真实来源，再加上 Argo CD 这种自动同步的系统，那么就能：

- **回滚更快速**：Argo CD 会定期拉取最新配置并应用到集群中，一旦新提交的配置导致应用出现故障，可通过 Git 历史将应用状态快速恢复到上一个可用状态。
- **集群灾备更简单**：假如某个可用区的 Kubernetes 集群出现故障，且短期内不可恢复。这个时候可以直接创建一个新集群，然后将 Argo CD 关联到 Git 仓库，新的集群将自动同步仓库内所有应用的配置声明，期间完全不需要人工干预。
- **合规及安全**：基于 Git 实现访问控制，开发人员 Pull Request，管理人员 Merge Request，没有额外的权限系统。且 Argo CD 已经部署在 Kubernetes 集群中，必须的访问权限已经配置妥当。除了集群管理员和少数人员外，其他人不再直接访问 Kubernetes 集群，这样就不再提供额外的证书、权限等，从而为 Kubernetes 集群提供更安全的保证。