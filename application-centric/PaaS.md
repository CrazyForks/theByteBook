# 10.1 “以应用为中心”的设计


声明式 API 的好处就在于，它能够在基础设施本身的复杂度以指数级攀升的同时，至少保证使用者的交互界面复杂度仍然以线性程度上升。


“复杂”，是任何一个基础设施项目天生的特质而不是缺点。基础设施本身的复杂度，并不意味着基础设施的所有使用者都应该承担所有这些复杂度本身。为了解决这个问题，很多公司落地 Kubernetes 的时候采用了 “PaaS” 化的思路，即在 Kubernetes 之上，开发一个类 PaaS 平台。

但这个设计，跟 Kubernetes “以应用为中心”的设计不一致，Kubernetes 一旦退化成“类IaaS 基础设施”，它的声明式 API、容器设计模式、控制器模式根本无法发挥原本的实力，也很难与广泛的生态对接。在 PaaS 系统上的体现就是不具备扩展性，假设我们要满足以下诉求：

- 能不能帮我运行一个定时任务
- 能不能帮我运运行一个 MySQL Operator
- 能不能根据自定义 metrics 定义水平扩容策略
- 能不能基于 Istio 来帮我做渐进式灰度发布
- 能不能...

这里的关键点在于，上述能力在 Kubernetes 生态中都是非常常见的的能力，有的甚至是 Kubernetes 内置就可以支持。但是到了 PaaS 这里，要支持上述任何一个能力，必须进行一轮开发。而且由于先前的一些假设和设计，甚至很可能需要大规模的重构。

具体来说，以“应用为中心”的基础设施：

只有让研发通过他自己的视角来定义应用，而不是定义 Kubernetes API 对象，才能从根本上解决 Kubernetes 使用者“错位”带来的各种问题。


符合以“应用为中心”的软件，从研发而不是基础设施的视角自描绘

更确切的说，原先通过应用中间件提供和封装的各种基础设施能力，现在全都被 Kubernetes 项目从应用层“拽”到了基础设施层也就是 Kubernetes 本身当中。而值得注意的是，Kubernetes 本身其实也不是这些能力的直接提供者，Kubernetes 项目扮演的角色，是通过声明式 API 和控制器模式把更底层的基础设施能力对用户“暴露”出去。


这也是为什么 CNCF 能够基于 Kubernetes 这样一个种子迅速构建起来一个数百个开源项目组成的庞大生态的根本原因：Kubernetes 从来就不是一个简单的平台或者资源管理项目，它是一个分量十足的“接入层”，是云原生时代真正意义上的“操作系统”。