# 第十章 应用封装与交付

:::tip <a/>
没有银弹，但有时会有很好用的弓箭。
:::right
—— 改自于著作《没有银弹》[^1]
:::

Docker 的核心价值在于设计了镜像，统一封装应用的部署与依赖，解决了单个应用实例在运行环境中的一致性问题。将应用的部署方式从手工作坊的部署方式带入了标准化的工业时代。Kubernetes 的出现，则对底层计算、网络、存储等资源进行了统一的抽象，这些抽象就是我们所熟知的 Pod、Service、NetworkPolicy，让多个容器共同协作，构建出健壮的分布式系统。

在 Kubernetes 的背景下，“软件”不再是一个由应用开发者掌控的单一交付物，而是多个 Kubernetes 对象的集合，使用 Kubernetes 原生语义构建一套现代微服务应用，是一件高度碎片化且充满挑战的事情。举个例子，如果你要在 Kubernetes 中部署一套微服务系统，那你需要为每个子服务配置 Service（提供服务发现和负载均衡）、Deployment（管理无状态服务）、HPA（提供自动扩缩容）、StatefulSet（管理有状态服务）、PersistentVolume（提持久化存储）、NetworkPolicy（提微网络访问控制规则）等等。上述工作“繁琐”还在其次，关键难点是写出合适 YAML 元数据描述，这要求操作人员既要懂研发（理解服务运行、镜像版本、依赖关系等需求），又要懂运维（理解扩缩容、负载均衡、安全、监控等策略），一般的开发人员根本无从下手。

以上复杂并不是 Kubernetes 导致，而是分布式应用天生的特质导致。但是分布式应用的诸多痛点不意味着应该由所有的使用者来承受。这就好比，Linux 内核是世界上最复杂的软件之一，但我们使用 Linux 内核并没有多少心智负担。这是因为 Linux 内核通过高度抽象化屏蔽了底层硬件和设备的复杂性，多数时候我们几乎感受不到 Linux 内核的存在。

所以说，上述困难的本质是，Docker 以镜像的形式封装了应用的依赖项，Kubernetes 以“资源”的形式封装了底层基础设施，但却缺乏一种应用层的软件交付模型和抽象，将研发工程师、运维工程师角色的关注点进行恰达的分离。既然 Kubernetes 被称为“云原生时代的操作系统”，现在，也该考虑学习 Linux 内核抽象方式，把底层基础设施能力以更为友好的途径透传给最终用户了。


:::center
  ![](../assets/GitOps.png)<br/>
  图 10-0 本章内容导读
:::


[^1]:《没有银弹：软件工程的本质性与附属性工作》是 IBM 大型机之父 Frederick P. Brooks, Jr. 的著作。书中通过引述《伦敦狼人》等电影的剧照，探讨了“银弹”在软件工程中的传说。Brooks 强调，由于软件本质上的复杂性，使真正的“银弹”（即完美解决所有问题的技术或方法）并不存在。