# 10.3 从“封装配置”到“应用模型”

在 Kubernetes 时代，“软件”不再是一个由应用开发者掌控的单一交付物，而是多个 Kubernetes 对象的集合。使用 Kubernetes 原生对象构建一套微服务应用，是一件高度碎片化且充满挑战的事情。

举个例子，如果你要在 Kubernetes 中部署一套微服务系统，那你需要为每个子服务配置 Service（提供服务发现和负载均衡）、Deployment（管理无状态服务）、HPA（自动扩缩容）、StatefulSet（管理有状态服务）、PersistentVolume（持久化存储）、NetworkPolicy（网络访问控制规则）等等。上述工作“繁琐”还在其次，关键难点是写出合适 YAML 元数据描述，这要求操作人员既要懂研发（理解服务运行、镜像版本、依赖关系等需求），又要懂运维（理解扩缩容、负载均衡、安全、监控等策略），一般的开发人员根本无从下手。

导致上面问题的根源在于，Kubernetes 的定位是“平台的平台”（The Platform for Platform），它的服务的对象是基础平台工程师，而非业务研发人员与运维人员；它的声明式 API 设计、CRD Operator 体系，也是为了方便基础平台工程师接入和构建新基础设施能力而设计的。这就导致作为这些能力的最终使用者 —— 业务研发人员，跟 Kubernetes 核心定位之间存在明显的错位。

“复杂” 是任何一个基础设施项目天生的特质而不是缺点，但这并不意味着这种“复杂”应该由使用者承受。这就好比，Linux 内核是世界上最复杂的软件之一，但我们使用 Linux 系统却没有太多心智负担，因为 Linux 系统通过高度抽象屏蔽了底层的复杂性。既然 Kubernetes 被称为“云原生时代的操作系统”，现在，也该考虑学习 Linux 抽象方式，寻找一种应用层的软件交付模型和抽象，以更友好的方式服务最终用户了。

接下来，笔者将介绍几种业界主流的应用封装与交付思路，供你参考。
