# 第七章：容器编排技术

:::tip <a/>

世界上有两个设计软件的方法，一种方法是设计的尽量简单，以至于明显没有什么缺陷，另外一种方式是使他尽量的复杂，以至于其缺陷不那么明显。

:::right
—— by C.A.R. Hoare[^1]
:::

以 Docker 为代表的容器引擎通过容器镜像封装应用及其所有依赖，为单体应用的测试、发布和部署提供了无缝的闭环流程，因此“以容器封装应用”逐渐成为广泛认可的最佳实践。然而，随着应用架构从单体向分布式转变，手动操作容器的弊端不断放大。因此，如何批量创建容器、如何分配资源、如何实现容器间通、如何在不同节点间调度容器，成为制约容器在大规模系统中应用的主要障碍。然而，想要在分布式系统中，也复刻单体应用那样的最佳实践之路，只有系统化地解决各类容器管理需求，如分配资源、容器间通信、弹性扩缩，不同节点间调度容器。对容器实现自动化部署、扩缩和管理的系统称之为容器编排系统。容器编排系统只有用最恰当的方式（成本最低、业务工程师友好）解决上述一系列容器管理问题，才能充分释放容器技术在分布式环境下的潜力。

在过去十年间，Kubernetes 已成为容器编排系统的事实标准，支撑着大数据分析、机器学习和在线服务等复杂分布式系统。虽然 Kubernetes 解决了许多复杂问题，但也成为了当今最复杂的软件系统之一。目前，包括官方文档在内的大多数 Kubernetes 资料都聚焦于工程细节，而少有对设计背后的原因进行解释。如果笔者仅停留在“是什么”和“怎么做”的层面，一则重复前人的工作，二则无法真正阐明 Kubernetes 的设计思想。

Google 从 2015 年起陆续公布了《Borg, Omega, and Kubernetes》以及《Large-scale cluster management at Google with Borg》等论文，论文介绍了开发和运维 Borg、Omega 和 Kubernetes 系统的经验与教训。我们从这几篇论文着手，了解 Google 内部容器系统是怎么演变的，汲取他人的设计思想后，再来深刻理解 Kubernetes 中关于容器资源分配、容器间通信和容器持久化存储的设计原理和应用。本章内容安排如图 7-0 所示。

:::center
  ![](../assets/container-summary.png)<br/>
  图 7-0 本章内容导图
:::

[^1]: Charles Antony Richard Hoare（缩写为 C. A. R. Hoare），著名的计算科学家，图灵奖获得者，以设计了快速排序算法、霍尔逻辑、通信顺序进程闻名。